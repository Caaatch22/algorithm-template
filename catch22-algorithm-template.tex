% !TeX program = xelatex 

%文档类型
\documentclass[a4paper]{ctexart}

%引用包裹
\usepackage{bm}
\usepackage{cmap}
\usepackage{cite}
\usepackage{color}
\usepackage{float}
\usepackage{xeCJK}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{indentfirst}
\usepackage[cache=false]{minted}
\usepackage{fontspec}
\usepackage{pdfpages}
\usepackage{fancyhdr}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{harpoon}
%代码高亮
\geometry{margin=1in}
\setmonofont{Consolas}
%字体设置
\setmainfont{Consolas}
%\setCJKmonofont{SimSun}
%\setCJKmainfont[BoldFont={SimSun}]{SimSun}

\hypersetup{
	colorlinks=true,
	linkcolor=black
}

\newcommand{\cppcode}[1]{
	\inputminted[mathescape,
	tabsize=2,
	linenos,
	%frame=single,
	framesep=2mm,
	breakaftergroup=true,
	breakautoindent=true,
	breakbytoken=true,
	breaklines=true,
	fontsize=\small
	]{cpp}{#1}
}

%\newcommand{\javacode}[1]{
%	\inputminted[mathescape,
%	tabsize=2,
%	linenos,
%	%frame=single,
%	framesep=2mm,
%	breakaftergroup=true,
%	breakbytoken=true,
%	breaklines=true,
%	fontsize=\small
%	]{java}{#1}
%}

%\newcommand{\vimcode}[1]{
%	\inputminted[mathescape,
%	tabsize=2,
%	linenos,
%	%frame=single,
%	framesep=2mm,
%	breakaftergroup=true,
%	breakautoindent=true,
%	breakbytoken=true,
%	breaklines=true,
%	fontsize=\small
%	]{vim}{#1}
%}

\begin{document}

\title{icpc算法模板}
\author{Catch-22}
\date{\today}

\maketitle

\newpage

\tableofcontents

\newpage

\section{数学}


\subsection{求逆元}
注意考虑$x$是$mod$倍数的情况
\cppcode{math/inverse.cpp}

\subsection{扩展欧几里德算法}
bezout定理：设$a, b$为正整数，则关于$x, y$的方程$ax + by = c$有整数解当且仅当$c$是$gcd(a, b)$的倍数。 \\
返回结果：$ax+by=gcd(a,b)$ 的一组解 (x, y)  \\
\indent 时间复杂度：$\mathcal{O}(nlogn)$
\cppcode{math/exgcd.cpp}

\subsection{BSGS}
find smallest non-negative $x$ s.t. $a^x = b \mod p$, or $-1$(assume $0^0 = 1$)
\cppcode {math/BSGS.cpp}

\subsection{筛法}
筛质数
\cppcode{math/getprime.cpp}
筛欧拉函数
\cppcode{math/phi.cpp}
筛莫比乌斯函数
\cppcode{math/getMu.cpp}

\subsection{组合数}
\begin{enumerate}
	\item $C_{n}^{m} = C_{n}^{n-m}$
	\item $C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1}$
	\item $C_{n}^{0} + C_{n}^{1} + \cdots +C_{n}^{n} = 2^n$
	\item $ lucas:\ C_{n}^{m} \equiv C_{n\ mod\ p}^{m\ mod\ p} * C_{n/p}^{m/p} $
\end{enumerate}

多重集组合数：

设$S = \{n_1 \cdot a_1, n_2 \cdot a_2, \cdots n_k \cdot a_k \}$是一个由$n_1$个$a_1$,$n_2$个$a_2$,$\cdots$,$n_k$个$a_k$组成的多重集。设$n = \sum_{i=1}^{k}n_i$，对于任意整数$r \leq n$，从$S$中取出$r$个元素组成一个多重集(不考虑顺序)，产生的不同多重集的数量为：
$$
C_{k+r-1}^{k-1} 
- \sum_{i=1}^{k}C_{k+r-n_i-2}^{k-1} 
+ \sum_{1 \leq i < j \leq k}C_{k+r-n_i - n_j-3}^{k-1}
- \cdots
+(-1)^k C_{k+r-\sum_{i=1}^{k}n_i-(k+1) }^{k-1} 
$$

多重集排列数：

多重集$S = \{n_1 \cdot a_1, n_2 \cdot a_2, \cdots n_k \cdot a_k \}$生成的排列是$\frac{(\sum_{i=1}^{k}n_i)!}{n_1 ! \cdot n_2! \cdots n_k !}$

\cppcode{math/combination.cpp}


\subsection{容斥原理}
$S_i$为有限集，$|S|$为$S$的大小（元素个数），则：
$$
| \bigcup\limits_{i=1}^{n} S_i | =\sum_{i=1}^{n} |S_i| - 
\sum_{1 \leq i < j \leq n}|S_i \cap S_j | 
+ \sum_{1 \leq i < j < k \leq n} |S_i \cap S_j \cap S_k | + \cdots 
+ (-1)^{n+1} | S_1 \cap \cdots \cap S_n | 
$$ 
\cppcode{math/inclu-exclu.cpp}

\subsection{数论分块}
考虑和式：
$\sum_{i=1}^{n}f(i) \lfloor \frac{n}{i} \rfloor$，由于$\lfloor \frac{n}{i} \rfloor$的值成一个块状分布，故可以一块一块运算。我们先求出$f(i)$的前缀和，每次以$[l, r] = [l, \lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor]$为一块分块求出贡献累加到结果中。(常配合莫反使用) \\
常见转换：
\begin{itemize}
	\item $\lceil \frac{a}{b} \rceil = \lfloor \frac{a-1}{b} + 1 \rfloor$
	\item $a\ mod\ b = a - \lfloor \frac{a}{b} \rfloor * b $ 
\end{itemize}
\cppcode{math/block-on-number.cpp}

\subsection{M\"{o}bius反演}
$\mu$为莫比乌斯函数，定义为
$$ \mu(x)=\left\{
\begin{aligned}
	&1   \  \  \ \ \ n = 1  \\
	&0    \  \  \ \ \  n\text{含有平方因子}  \\
	&(-1)^k  \  \ k \text{为n本质不同的质因子个数} \\
\end{aligned}
\right.
$$
性质：
$$ \sum_{d|n} \mu(d)=\left\{
\begin{aligned}
	&1   \  \  \ \ \ n = 1  \\
	&0   \  \  \ \ \ n \neq 1 \\
\end{aligned}
\right.
$$
证：设 $n = \prod_{i=1}^{k}p_i^{c_i},
n^{\prime} = \prod_{i=1}^{k}p_i$ \\
那么$\sum_{d|n} \mu(d) = \sum_{d|n^{\prime}} \mu(d) 
= \sum_{i=0}^{k}C_{k}^i \cdot (-1)^i 
= (1+(-1))^k = 1$ \\
反演：\\
形式一：
$$f(n) = \sum_{d|n}{g(d)} \Leftrightarrow g(n) = \sum_{d|n}{\mu(d)f(\frac{n}{d})}$$
证：
$$
\sum_{d \mid n} \mu(d) f\left(\frac{n}{d}\right)=\sum_{d \mid n} \mu(d) \sum_{k \mid \frac{n}{d}} g(k)=\sum_{k \mid n} g(k) \sum_{d \mid \frac{n}{k}} \mu(d)=g(n)
$$
用$\sum_{d|n}g(d)$来替换$f(\frac{n}{d})$，再变换求和顺序。最后一步变换的依据：$\sum_{d|n}\mu(d) = [n=1]$，因此在$\frac{n}{k}=1$时第二个和式的值才为 。此时$n=k$，故原式等价于$\sum_{k|n}[n=k]\cdot g(k) = g(n)$ \\  
形式二：
$$f(n) = \sum_{n|d}{g(d)} \Leftrightarrow g(n) = \sum_{n|d}{\mu(\frac{d}{n})f(d)}$$



\subsection{高斯消元}
\cppcode{math/Gauss.cpp}

\subsection{Miller\ Rabin\ 素数测试}
\cppcode{math/mr-test.cpp}

\subsection{FFT}
\cppcode{math/fft.cpp}

\section{数据结构}


\subsection{(带权)并查集}
\cppcode{data-structure/disjointSet.cpp}

\subsection{Sparse Table}
时间复杂度$\mathcal{O}(1)$，空间复杂度$\mathcal{O}(nlogn)$ \\
静态区间查询可重复贡献信息，如“区间最值”、“区间按位和”、“区间按位或”、“区间 GCD”
\cppcode{data-structure/sparse-table.cpp}

\subsection{01Trie}
\cppcode{data-structure/01Trie.cpp}

\subsection{树状数组}
\cppcode{data-structure/fenwich-tree.cpp}

\subsection{线段树}
\cppcode{data-structure/SegTree.cpp}
扫描线：(面积)
\cppcode{data-structure/SegTree-Xray.cpp}

\subsection{可持久化线段树}
\cppcode{data-structure/persistentSegTree.cpp}

\subsection{线段树合并}
\cppcode{data-structure/segtree-merge.cpp}

\subsection{树链剖分}
\cppcode{data-structure/HeavyPathDecomposition.cpp}


\subsection{左偏树}
支持操作(以维护最小值为例)：
\begin{enumerate}
	\item 找到最小值 $\mathcal{O}(1)$
 	\item 删除最小值 $\mathcal{O}(logn)$
	\item 插入一个值 $\mathcal{O}(logn)$
	\item 合并两个堆 $\mathcal{O}(logn)$
\end{enumerate}
\cppcode{data-structure/leftish-tree.cpp}

\subsection{莫队}
普通莫队：
\cppcode{data-structure/Mo.cpp}
待修莫队：
\cppcode{data-structure/modifyMo.cpp}

\section{图论}
\subsection{spfa}
\cppcode{graph/spfa.cpp}

\subsection{dijkstra}
稀疏图dijkstra：
\cppcode{graph/dij1.cpp}
稠密图dijkstra：
\cppcode{graph/dij2.cpp}

\subsection{最小生成树}
\cppcode{graph/MST.cpp}
另外，对于完全图的$MST$问题，可以考虑使用$Boruvka$算法。我们要在$nlogn$或$nlog^2n$时间内求出每个连通块最小的连接的边，而这个边权一般可通过点权以一定方式求出。 通常不用直接写出，运用该思想求解。

\subsection{kruskal重构树}
\cppcode{graph/kruskalRebuildTree.cpp}

\subsection{二分图匹配}
二分图匹配的模型有两个要素：
\begin{enumerate}
	\item 节点能分成独立的两个集合，每个集合内部有$0$条边
	\item 每个节点只能与$1$条匹配边相连
\end{enumerate}
二分图最小覆盖模型特点是：每条边有$2$个端点，二者至少选择一个。 \\
k\"{o}nig定理：二分图最小点覆盖包含的点数等于二分图最大匹配数包含的边数。\\
图的最大独立集：点集$S$中任意两点之间都没有边相连。其大小等于$n -$最大匹配数。(n是二分图总点数)
\cppcode{graph/BipartiteMatch.cpp}


\subsection{强连通分量缩点}
时间复杂度$O(m+n)$，反向枚举scc\_cnt即是新图拓扑序。
\cppcode{graph/tarjan-scc.cpp}

\subsection{无向图的双连通分量}
桥：
\cppcode{graph/tarjan-eDcc.cpp}
割点：
\cppcode{graph/tarjan-vDcc.cpp}



\subsection{lca}
\cppcode{graph/LCA.cpp}

\subsection{基环树}
基环树的性质：点数等于边数；度数是点数两倍。一般题目中出现“从一个点到另一个点建一条边”，“N个点通过恰好N条双向道路连接起来，不存在任何两条道路连接了相同的两个点”等类似信息可以判定该图是基环树森林。以下是求基环树(森林)直径(和)代码
\cppcode{graph/pseudotree-diameter.cpp}

\subsection{dinic}
\cppcode{graph/Dinic.cpp}

\section{动态规划}

\subsection{数位dp}


\subsection{换根dp}
换根dp一般时间复杂度为$\mathcal{O}(n)$，需要对树处理得到大规模答案，如对每个点得到一个答案。
\cppcode{DP/tree-change-root.cpp}

\section{字符串}


\subsection{字符串Hash}
\cppcode{string/stringHash.cpp}

\subsection{Trie}
\cppcode{string/Trie.cpp}

\subsection{KMP}
\cppcode{string/kmp.cpp}

\subsection{Z-algorithm}
\begin{itemize}
	\item 给出字符串$a, b$，求$a$的每个后缀与$b$的LCP： \\
	设$ \$ $为字符集外字符，求 $b+\$+a$的Z函数，则$a$的后缀$a[i..]$与$b$的LCP为 $Z(|b| + 1 + i)$ 。
	\item 求$s$的每个前缀的出现次数：\\
	求$s$ 的Z函数。对于每一个 $i$ ，如果 $Z(i)$ 不等于$0$，说明长度为 $Z(i), Z(i) - 1, \cdots , 1$ 的前缀在此处各出现了一次，所以求一个后缀和即可。在这个问题中一般令$Z(0) = |s|$。
	\begin{minted}{cpp}
for (int i = n + 1; i < 2 * n + 1; ++i)
    S[z[i]]++;
for (int i = n; i >= 1; --i)
    S[i] += S[i + 1];
	\end{minted}

	\item 求 $s$的所有border: \\
	KMP就可以，也可以用Z算法。求$s$的$Z$函数。对于每一个 $i$，如果 $i+Z(i) = |s|$ ，说明这个Z-Box对应一个border。（注：与KMP不同，这里只是求所有border，不是求所有前缀的border）
\end{itemize}

\cppcode{string/z-algorithm.cpp}

\subsection{AC自动机}
\cppcode{string/AC.cpp}

\subsection{SA}
$lcp(i, j)$表示后缀$i, j$的最长公共前缀(的长度)

$height$数组定义： 
$ht[i] = lcp(sa[i], sa[i - 1])$

性质：
$lcp(sa[i], sa[j]) = min\{ht[i + 1..j]\}$ \\
由此，求两子串(排名为$i,j$)最长公共前缀就转化为了$RMQ$ 问题(求$ht[i+1]$到$ht[j]$的最小值)。

本质不同的子串：$\frac{n*(n+1)}{2} - \sum_{i=2}^{n}ht[i]$

$ht$数组连续一段不小于$h$的区间长度代表长$h$的这个子串的出现次数

\cppcode{string/SA.cpp}


\subsection{Manacher}
用$Manacher+hash$可以求出所有本质不同的回文子串(存hash值),时间复杂度$\mathcal{O}(|s|)$。但是不用于求每个本质不同回文子串出现次数相关统计，因为统计出现次数时，$while(l<=r)$中不可以$break$，复杂度$n^2$
	\begin{minted}{cpp}
    auto p = manacher(s);
    Hash hs(s); //or doubleHash
    set<ull> res; // ll when doubleHash
    for (int mid = 1; mid < p.size() - 1; mid ++) {
        //枚举回文子串的左右端点
        int l = (mid - p[mid] + 1) / 2, r = (mid + p[mid] - 1) / 2;
        while(l <= r) {
            if(res.count(hash.get(l, r))) break;
            res.insert(hash.get(l++, r--));
        }
    }
\end{minted}

\cppcode{string/manacher.cpp}


\section{其他}
\subsection{glibc内置函数}
\cppcode{others/builtin-functions.cpp}

\subsection{\_\_int128读写}
\cppcode{others/int128-read-put.cpp}

\subsection{整数二分}
\cppcode{others/binary-answer.cpp}

\subsection{单调栈}
\cppcode{others/monotoneS.cpp}

\subsection{单调队列}
\cppcode{others/monotoneQ.cpp}

\subsection{GospersHack}
生成$n$元集合所有$k$元子集的算法。这个算法复杂度与答案个数是同阶的，比暴力枚举$2^n$个数然后分别算$popcount$要好。
\cppcode{others/GospersHack.cpp}

\subsection{C++17-STL}
\cppcode{others/c++17-and-STL.cpp}

\end{document}
